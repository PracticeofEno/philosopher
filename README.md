# philosopher
```
git clone ~
make
./philo 2 200 100 100 -> 순서대로 철학자 수, 죽는데 걸리는 시간, 먹는시간, 자는시간
./philo 2 200 100 100 2 -> 2번씩 먹으면 종료하는 경우
./philo 2 150 100 100 -> 무조건 죽을 수 밖에 없는 경우
```
### 0. 과제에 있는 개념
- 공유 자원에서의 상호배제
- 상호배제에 대한 개념정리는 구글링하면 나오는 글중 하나로 대체하겠습니다 
- 출처 : https://chelseashin.tistory.com/40

### 1. 개념 이미지
![2022-11-16 오후 2-43-15](https://user-images.githubusercontent.com/57505385/202093767-862491ee-947d-466c-a8be-426eb3a0cce2.png)
### 2. 과제 요구조건
| 필수 충족사항 | 
| --- |
| - 에러나면 0점 |
| - 한명 이상의 철학자가 원탁에 앉아  먹고, 생각하고, 잠자기 세가지 중 하나를 합니다 |
| - 먹는 동안에는 생각하거나 자지않고, 잠자는 동안에는 먹거나 생각하지 않고, 생각하는 동안에는 먹거나 자지 않습니다. (하나의 행동만 할 수 있습니다) |
| - 철학자들은 커다란 스파게티 그릇이 있는 원형 테이블에 앉습니다. |
| - 테이블에 포크가 있습니다. |
| - 한손에 하나씩. 두개의 포크로 먹어야 합니다. |
| - 철학자는 절대 굶어서는 안됩니다. |
| - 철학자들은 서로 이야기하지 않습니다. ( 철학자끼리 통신 불가 ) |
| - 철학자들은 다른철학자가 언제 죽을지 모릅니다 (다른 철학자 정보 X) |
| - 철학자는 식사를 마치면 포크를 놔두고 잠자기 시작합니다 |
| - 철학자는 잠이 끝나면 생각하기 시작합니다. |
| - 철학자가 죽으면 시뮬레이션이 중지됩니다. |
| - 철학자의 수는  1부터 199까지의 숫자를 부여받습니다. |
| - 철학자 번호 n은 n-1과 n+1 사이에 앉습니다. |
| - 인쇄된 상태는 다른철학자의 상태와 뒤섞이거나 얽히지 않아야 합니다 |
| - 철학자의 죽음과 그 죽음의 인쇄는 11ms이상 차이가 나면 안됩니다 |
| - 다시 말하지만 철학자는 죽음을 피해야 합니다. |
| - 철학자가 포크를 복제하는것을 방지하려면 각각에 대한 뮤텍스로 포크 상태를 보호해야 합니다. |
| - 각 철학자는 Thread가 되어야 합니다 |

- 철학자의 상태 변경은 다음과 같이 작성해야 합니다  
◦ timestamp_in_ms X has taken a fork  
◦ timestamp_in_ms X is eating  
◦ timestamp_in_ms X is sleeping  
◦ timestamp_in_ms X is thinking  
◦ timestamp_in_ms X died  

 - 각 프로그램에는 동일한 옵션이 있어야합니다
1. number_of_philosophers : 철학자의수 , 포크의 수 
2. time_to_die : 밀리초 단위. 마지막 식사시작이나 시뮬레이션이 시작된 후 time_to_die 까지 먹지 못하면 죽는다. 
3. time_to_eat : 밀리초단위. 철학자가 식사하는데 걸리는 시간. 그 시간동안 두개의 포크 점유 
4.  time_to_sleep : 밀리초단위. 철학자가 잠을 자는 시간 

### 3. 공용 구조체와 개인 구조체
- 공유하여 쓸 구조체변수 share와, 각각의 철학자 개인의 정보를 지닐 indivi구조체 모습
![2022-11-16 오후 5-29-24](https://user-images.githubusercontent.com/57505385/202128345-98b800f0-32c2-4c2f-850e-aa0845d9eec9.png)

### 4. 공통적으로 사용하여 잠그어줘야 할 요소
1. 포크
2. printf 출력부
3. 해당 철학자가 죽었는지 살았는지 체크하는 부분
4. 먹는 행동
5. 가장 자원을 적게 할당받은 철학자의 시간

### 5. 순서도  
![철학자 순서도](https://user-images.githubusercontent.com/57505385/202152719-3059e1fb-ada5-4788-b4da-673ba08cf0b1.png)

### 6. 기억에 남는 문제
- thread를 쉬어주어야 할때, 쉬어야할 시간이 800ms라고 가정하면 800ms를 통째로 쉬어버리면 몇가지 문제점이 발생했었음
- 1. sleep, eat 하면서 죽는경우, 탐지 불가
- 2. CPU할당을 최소 800ms이후에 받기때문에 딜레이가 누적됨
- 2-0. 800ms이후 runnable상태에서 CPU를 할당 받을때까지 걸리는 시간이 누적되서 오차가 발생함
- 2-1. Thread 생명주기에 관한 개념은 다른분의 글을 링크하겠습니다 
- 2-2. [https://shrtorznzl.tistory.com/11](https://codedragon.tistory.com/3526)
- example)
```
usleep(800);
```
-> 해결 : 800ms를 쉬더라도 실제론 잘게 쪼개서 쉬게 변경
```
int	divide_sleep(int goal_time, t_share *share, t_indivi *indivi)
{
	long	time;
	time = get_time() + goal_time;
	usleep(goal_time * 900);
	while (time > get_time())
		usleep(share->philo_count * 2.3);
        ...
	return (0);
}
```

### 7. 실행 결과 
- 출력을 명확히 알아보기 위해 철학자 수를 알아보기 쉽게 2개로 설정하였고 죽는경우, 2번씩 먹으면 종료하는 경우, 무한히 먹는 경우 세가지로 나누어 출력결과를 보았다  
- 2번 먹고 종료하는 경우  
![2번먹기](https://user-images.githubusercontent.com/57505385/202156600-a23fde2b-b976-4940-9b74-e2754a5985d8.png)
- 무한히 먹기  
![무한히](https://user-images.githubusercontent.com/57505385/202156744-e1d71887-55ba-4070-a447-2cd93be8b7e6.png)
- 죽는 경우 (0번 철학자가 먼저 먹고 150ms에 1번 철학자가 수저를 받아 먹지만 생존시간 150ms를 초과해서 201ms에 죽었다고 표시가 뜸)  
![죽는경우](https://user-images.githubusercontent.com/57505385/202156611-0e077ec7-139d-47d1-a328-43d60849309a.png)
